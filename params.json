{"name":"fFixture","body":"# Introduction\r\n\r\nfFixture provides an easy way of creating sample data (fixtures) for unit testing using [Flourish](http://flourishlib.com).\r\n\r\nIt recursively creates records based on JSON fixture files that you provide. By default it will create records for all fixture files it finds, but you can specify to use only selected fixtures.\r\n\r\n\r\n## Usage\r\n\r\nCreate `JSON` fixture files like this `users.json`:\r\n\r\n\t[\r\n\t\t{\r\n\t\t\tuser_id: 1,\r\n\t\t\tname: \"Will Bond\",\r\n\t\t\tcontribution: \"Creator of Flourish\"\r\n\t\t}\r\n\t]\r\n\r\nCreate a fixture instance:\r\n\r\n\tfFixture::setDatabase($db);\r\n\t$fixture = fFixture::create('/path/to/fixtures/');\r\n\t\r\n\t$fixture->build();\r\n\r\nUse your newly created objects:\r\n\r\n\t$user = new User(1);\r\n\techo $user->getName() // outputs: Will Bond\r\n\r\nBring everything down again:\r\n\r\n\t$fixture->tearDown();\r\n\r\nThat's pretty much it. Check the unit tests in `/tests` for a working example.\r\n\r\n## Unit tests\r\n\r\nThe whole idea of this class was to ease the creating an maintanance of unit tests. Here is a simple example of how to setup and tear down the fixtures.\r\n\r\nThe setup, in this case run after each test:\r\n\r\n    public function setUp()\r\n    {\r\n        $db = fORMDatabase::retrieve();\r\n        fFixture::setDatabase($db);\r\n        $this->fixture = fFixture::create('/path/to/fixtures/', array(\"users\", \"marketplaces\"));\r\n        $this->fixture->build();\r\n    }\r\n\r\n.. and the tear down:\r\n   \r\n    public function tearDown()\r\n    {\r\n\t\t$this->fixture->tearDown();\r\n    }\r\n\r\nThe fixtures root will typically contain lots of fixtures that can be or is need for several tests. But sometimes you cannot rely on this random data. Maybe you need to know that you have _exactly_ three products or an record with a specific value. In this case you can specify a third parameter - replacments root. Basically when loading the fixtures the fixtures of the replacments root will be used in favor of those in the root directory.\r\n\r\nIn this case these special `user` objects are placed along with the unit test itself:\r\n\r\n\tpublic function setUp()\r\n\t{\r\n        $db = fORMDatabase::retrieve();\r\n        fFixture::setDatabase($db);\r\n        $this->fixture = fFixture::create('/path/to/fixtures/', array(\"users\", \"marketplaces\"), '/path/to/unittest/fixtures/');\r\n        $this->fixture->build();\r\n\t}\r\n\r\nAssume that `/path/to/fixtures/` contains the following:\r\n\r\n    ./users.json\r\n\t./shops.json\r\n\t./marketplaces.json\r\n\r\nand that `/path/to/unittest/fixtures/` contains the following:\r\n\r\n\t./users.json\r\n\r\nThen the build order of the fixtures will be:\r\n\r\n1. `/path/to/fixtures/shops` - as `User`s has dependencies on `Shop`s\r\n2. `/path/to/unittest/fixtures/users.json` - as the unit test has specific `User` fixtures.\r\n3. `/path/to/fixtures/marketplaces.json` - these are specifed as well but there are no unit test specific versions of these fixtures.\r\n\r\nThis allows for some flexibility. But note the possibility of failure in case the _root_ fixtures are dependent on a type of fixture that has been overwritten by the unit test fixtures or vice versa.\r\n\r\n## Fixture files\r\n\r\nThe fixture files contains an array of JSON literals. Like this `members.json`:\r\n\r\n\t[\r\n\t\t{\r\n\t\t\t\"name\":\"Michael\",\r\n\t\t\t\"country\":\"Nepal\",\r\n\t\t\t\"member_since\":\"2009-05-23\"\r\n\t\t}\r\n\t]\r\n\r\nThough JSON, the files will first be evaluated as PHP scripts, so you can included `<?php echo data('Y-m-d H:i:s); ?>` into you JSON files.\r\n\r\n\t[\r\n\t\t{\r\n\t\t\t\"name\":\"Michael\",\r\n\t\t\t\"country\":\"Nepal\",\r\n\t\t\t\"member_since\":\"<?php echo data('Y-m-d); ?>\"\r\n\t\t}\r\n\t]\r\n\r\nYou could also go crazy building all the objects from PHP.\r\n\r\n## Namespaces\r\n\r\nIf you use namespaces, either make sure that you have included the name spaced classes before running fFixture::create(). Alternativly you can use the `fORM::mapClassToTable()` method:\r\n\r\n\tfORM::mapClassToTable('My\\Namespaced\\Class', 'classes');\r\n\r\n## Limitations\r\n\r\n* The class does not handle multiplie cases where you have records split over several database. It will either use the default ORM database or the one you supply using setDatabase().\r\n* Only table dependency is supported and only at one level.\r\n* No real key checking, the validity of the records is left to fORM - but it does that pretty good anyway.\r\n* No schema creation - you need a database setup with all the tables.\r\n\r\n## Future\r\n\r\nSome ideas for the futre in no particular order:\r\n\r\n - Implement auto-fill mode (missing properties, dependencies, etc.)\r\n - Handle selfreferencing patterns like, trees.\r\n - Support for complex primary keys\r\n - Helper method to easily work references in relationships. (eg. page uses [column layout])\r\n - Other input source (eg. string, array)\r\n - passing a build tables and drop tables script\r\n - nested records","tagline":"Provides an easy way of creating sample data (fixtures) for unit testing using Flourish.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}